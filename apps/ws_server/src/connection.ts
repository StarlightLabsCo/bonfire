import { ServerWebSocket } from 'bun';
import { WebSocketData } from '.';
import { redis } from '../services/redis';
import { StarlightWebSocketResponse } from 'websocket/types';

// TODO: big open question, previously I was just using connectionId as the key?! but that's really bad cause that's generated by the client
// TODO: need to figure out how to handle this, maybe just use the userId as the key and then have a list of connectionIds?
// TODO: maybe I need to handle the case of a user having multiple tabs open? that's a bit more complicated, but i could just kick them out of the old one

// Connection Manager: Abstracts the websocket from the user's session.
// If the websocket disconnects, messages are queued via the user's connection ID and sent upon reconnection.
// If a new websocket connects with the same connection ID, the old one is cleared and messages are directed to the new one.

// Connection ID represents the user's session and is client-determined. On hard refresh, a new connection ID is assigned.
// This is used for the websocket queuing system to maintain stability during connection disruptions.
// On hard refresh, the user receives all latest data via NextJS, eliminating the need for queued messages.
export const connectionIdToWebSocket: {
  [key: string]: ServerWebSocket<WebSocketData> | null;
} = {};

export async function handleWebsocketConnected(
  connectionId: string,
  ws: ServerWebSocket<WebSocketData>,
) {
  connectionIdToWebSocket[connectionId] = ws;

  // Clear out any old connectionIds from the user
  const oldKeys = await redis.keys(`${ws.data.webSocketToken!.userId}-*`);
  const keysToDelete = oldKeys.filter(
    (key) => key !== `${ws.data.webSocketToken!.userId}-${connectionId}`,
  );
  if (keysToDelete.length > 0) {
    console.log(`Deleting old connection keys: ${keysToDelete}`);
    await redis.del(...keysToDelete);
  }

  // Send any queued messages
  const queuedMessages = await redis.lrange(connectionId, 0, -1);
  for (const message of queuedMessages) {
    ws.send(message);
  }
  await redis.del(connectionId);
}

async function send(userId: string, data: StarlightWebSocketResponse) {
  const websocket = connectionIdToWebSocket[ws.data.connectionId!];

  if (websocket && websocket.readyState === 1) {
    websocket.send(JSON.stringify(data));
  } else {
    redis.rpush(ws.data.connectionId!, JSON.stringify(data));
  }
}

export function clearWebsocketFromConnection(connectionId: string | null) {
  if (!connectionId) return;

  connectionIdToWebSocket[connectionId] = null;
}
